%{
/*
 * selecção de instruções com postfix
 */
#include <stdio.h>
#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include "node.h"
#include "postfix.h"
#include "y.tab.h"
#include "minor.h"

#ifndef U_
#define U_ "_"
#endif

#define TRACE
static void yytrace(NODEPTR_TYPE p, int eruleno, int cost, int bestcost);

extern FILE *yyout;

int lbl;

static char *mklbl(int n) {
	static char buf[20];
	sprintf(buf, "%cL%d", n < 0 ? '.' : '_', n);
	return strcpy(malloc(strlen(buf)+1),buf);
}
static char *mkfunc(char *s) {
	static char buf[80];
	strcpy(buf, "_");
	strcat(buf, s);
	return buf;
}

static void outstr(char *s) {
  while (*s) fprintf(yyout, pfCHAR, (unsigned char)*s++);
  fprintf(yyout, pfCHAR, 0);
}
static int onlyINT(Node *n) { return LEFT_CHILD(n)->info == tINT ? 1 : 10000;} 

static int onlySTR(Node *n) { return LEFT_CHILD(n)->info == tSTR ? 1 : 10000;} 

static int isINT(Node *n) { return (LEFT_CHILD(n)->info == tINT && RIGHT_CHILD(n)->info == tINT) ? 1 : 10000; } 

static int add(Node *n) { return ((LEFT_CHILD(n)->info == tINT && RIGHT_CHILD(n)->info == tINT) || 
																		(LEFT_CHILD(n)->info == tVEC && RIGHT_CHILD(n)->info == tINT) ||
																		(LEFT_CHILD(n)->info == tINT && RIGHT_CHILD(n)->info == tVEC)) ? 1 : 10000; }

static int sub(Node *n) { return ((LEFT_CHILD(n)->info == tINT && RIGHT_CHILD(n)->info == tINT) || 
																		(LEFT_CHILD(n)->info == tVEC && RIGHT_CHILD(n)->info == tINT) ||
																		(LEFT_CHILD(n)->info == tVEC && RIGHT_CHILD(n)->info == tVEC) ||
																		(LEFT_CHILD(n)->info == tINT && RIGHT_CHILD(n)->info == tVEC)) ? 1 : 10000; }

static int fwd(Node *n) { return n->info & tFWD ? 1 : 10000; }
static int pub(Node *n) { return n->info & tPUB? 1 : 10000; }

%}
%term STMT=';' EXCL='!' CARD='#' PARE='[' IN='?' ADD='+' SUB='-' MUL='*' DIV='/' MOD='%' POW='^' EQUAL='=' MIN='<' MAX='>' AND='&' OR='|' NOT='~' CURVE='(' COMMA=',' 
%include "y.tab.h"
%%
file: PROGRAM(finaldecls, FUNCTION(END(ID, INT), FARGS(NIL, main))) 1 { fprintf(yyout, pfIMM pfPOP pfLEAVE pfRET, 0); }
file: MODULE(finaldecls)	1 { fprintf(yyout, pfIMM pfPOP pfLEAVE pfRET, 0); }

finaldecls: decls { fprintf(yyout, pfGLOBL pfTEXT pfALIGN pfLABEL pfENTER , "_main", pfFUNC, "_main", 0); }

decls: NIL
decls: gdecls 1 {}

gdecls: DECL(gdecls, decl) 1 {}
gdecls: DECL(NIL, decl) 1 {}


decl: VAR(fvardecl) fwd
decl: VAR(pvardecl) pub
decl: VAR(vardecl)  10

%!decl: VAR(vardecl) 1 { if (p->info & tFWD) { fprintf(yyout,pfEXTRN, LEFT_CHILD(LEFT_CHILD(p))->value.s); } else if (p->info & tPUB){ fprintf(yyout, pfGLOBL, LEFT_CHILD(LEFT_CHILD(p))->value.s, pfOBJ); } /*if (LEFT_CHILD(RIGHT_CHILD(LEFT_CHILD(p))) == NIL){fprintf(yyout, pfBSS pfALIGN pfLABEL pfBYTE, LEFT_CHILD(LEFT_CHILD(p))->value.s, RIGHT_CHILD(LEFT-CHILD(p))->value.i);} else {fprintf(yyout, pfDATA pfALIGN pfLABEL pfINTEGER, LEFT_CHILD(LEFT_CHILD(p))->value.s, RIGHT_CHILD(LEFT-CHILD(p))->value.i);} */ }

decl: FUNCTION(END(ID, INT), FARGS(fvars, eqbody)) 1 {}
decl: FUNCTION(END(ID, INT), FARGS(NIL, eqbody)) 1 {}
decl: NIL	

fvar: NUMBER(ID, NIL) 1 {}
fvar: STRING(ID, NIL) 1 {}
fvar: ARRAY(ID, INTS(vdim, NIL)) 1 {}

fvars: ARGS(NIL, fvar) 1 {}
fvars: ARGS(fvars, fvar) 1 {}


fvardecl: NUMBER(ID, eqint) 1 {  fprintf(yyout, pfEXTRN pfDATA pfALIGN pfLABEL pfINTEGER, LEFT_CHILD(p)->value.s, LEFT_CHILD(p)->value.s, RIGHT_CHILD(p)->value.i); }
fvardecl: STRING(ID, eqstr) 1 { /*fprintf(yyout, pfData pfALIGN pfLABEL);*/}
fvardecl: ARRAY(ID, INTS(vdim, eqvec)) 1 {}

pvardecl: NUMBER(ID, eqint) 1 { fprintf(yyout, pfGLOBL pfDATA pfALIGN pfLABEL pfINTEGER, LEFT_CHILD(p)->value.s, pfOBJ, LEFT_CHILD(p)->value.s, RIGHT_CHILD(p)->value.i); }
pvardecl: STRING(ID, eqstr) 1 { fprintf(yyout, pfGLOBL pfDATA pfALIGN pfLABEL pfID, LEFT_CHILD(p)->value.s, pfOBJ, LEFT_CHILD(p)->value.s, mklbl(lbl));}
pvardecl: ARRAY(ID, INTS(vdim, eqvec)) 1 {}

vardecl: NUMBER(ID, eqint) 1 { fprintf(yyout, pfDATA pfALIGN pfLABEL pfINTEGER, LEFT_CHILD(p)->value.s, RIGHT_CHILD(p)->value.i); }
vardecl: STRING(ID, eqstr) 1 { /*fprintf(yyout, pfData pfALIGN pfLABEL);*/}
vardecl: ARRAY(ID, INTS(vdim, eqvec)) 1 {}

vdim: INT 1 {}
vdim: NIL

eqint: NIL 
eqint: INT 1 { /*fprintf(yyout, pfINTEGER, p->value.i);*/ }

eqstr: NIL 
eqstr: chars 1 {}

chars: CHARS(NIL, char) 1 {} 
chars: CHARS(chars, char) 1 {}

char: INT 1 { fprintf(yyout, pfIMM, p->value.i); }
char: CHAR 1 { fprintf(yyout, pfIMM, p->value.i); }
char: STR 1 { lbl++; fprintf(yyout, pfRODATA pfALIGN pfLABEL, mklbl(lbl)); outstr(p->value.s); fprintf(yyout, pfTEXT pfADDR, mklbl(lbl)); }

eqvec: NIL 
eqvec: ints 1 {}

ints: INT 1 {}
ints: INTS(ints, INT) 1 {}

eqbody: NIL 
eqbody: body 1 {}

main: START(fvars, instrs) 1 {}
main: START(NIL, instrs) 1 {}

body: START(fvars , STMT(instrs, ret)) 1 {}
body: START(NIL , STMT(instrs, ret)) 1 {}

ret: RETURN(NIL)  1 {}
ret: RETURN(expr) 1 {} 
ret: NIL 

loop: ret	1 {}
loop: REPEAT 1 {} 
loop: STOP 1 {} 

block: STMT(instrs, loop) 1 {} 

instrs: NIL 
instrs: STMT(instrs, instr) 1 { /*fprintf(yyout, );*/ } 

instr: FI(THEN(IF(expr, block), elifs), else) 1 {} 
instr: FOR(UNTIL(expr, expr), STEP(block, expr)) 1 {} 
instr: EXCL(expr) onlySTR { fprintf(yyout, pfEXTRN pfCALL pfTRASH, "_prints", "_prints", 4);} 
instr: EXCL(expr) onlyINT { fprintf(yyout, pfEXTRN pfCALL pfTRASH, "_printi", "_printi", 4);} 
instr: expr 1 {} 
instr: CARD(expr, lval) 1 {} 

elifs: NIL 
elifs: ELIF(elifs, IF(expr, block)) 1 {} 

else: NIL 
else: block 1 {}

lval: ID 1 {} 
lval: PARE(expr, ID) 1 {} 

expr: chars 1 { /*fprintf(yyout, pfADDR);*/ }
expr: lval 1 { fprintf(yyout, pfADDR pfLOAD, p->value.s);}
expr: IN 1 { fprintf(yyout, pfEXTRN pfCALL pfTRASH pfPUSH, "_readi", "_readi", 0);} 
expr: ADDR(lval) 1 {}
expr: expr 1 {} 
expr: ADD(expr, expr) add { fprintf(yyout, pfADD); } 
expr: SUB(expr, expr) sub { fprintf(yyout, pfSUB); } 
expr: MUL(expr, expr) isINT { fprintf(yyout, pfMUL); } 
expr: DIV(expr, expr) isINT { fprintf(yyout, pfDIV); } 
expr: MOD(expr, expr) isINT { fprintf(yyout, pfMOD); } 
expr: POW(expr, expr) isINT {} 
expr: EQUAL(expr, expr) 1 {} 
expr: NE(expr, expr) 1 {} 
expr: GE(expr, expr) 1 {} 
expr: LE(expr, expr) 1 {} 
expr: MIN(expr, expr) 1 {} 
expr: MAX(expr, expr) 1 {} 
expr: AND(expr, expr) 1 {} 
expr: OR(expr, expr) 1 {} 
expr: NOT(expr) 1 {} 
expr: uminus(expr) 1 {} 
expr: EQ(expr, lval) 1 {} 
expr: CURVE(ID, exprs) 1 {} 

exprs: COMMA(expr, NIL) 1 {} 
exprs: COMMA(expr, exprs) 1 {} 
%%
extern char **yynames;
extern int trace, errors, debugNode;
void evaluate(Node *p) {
	if (errors) return;
	if (trace)  printNode(p, stdout, yynames);
	if (!yyselect(p) && trace) printf("selection successful\n");
}

#ifndef NOTRACE
static void yytrace(NODEPTR_TYPE p, int eruleno, int cost, int bestcost)
{
	int op = OP_LABEL(p);
	YYCONST char *tname = yytermname[op] ? yytermname[op] : "?";
	if (debugNode) fprintf(stderr, "0x%p:%s matched %s with cost %d vs. %d\n", p, tname, yystring[eruleno], cost, bestcost);
	if (cost >= MAX_COST && bestcost >= MAX_COST) {
		fprintf(stderr, "0x%p:%s NO MATCH %s with cost %d vs. %d\n", p, tname, yystring[eruleno], cost, bestcost);
		/*printNode(p, stderr, yynames);*/
	}
}
#endif
